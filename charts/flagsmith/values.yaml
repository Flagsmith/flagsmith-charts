common:
  # Labels to add to all the resources deployed by this chart
  labels: {}
  # Annotations to add to all the resources deployed by this chart
  annotations: {}

api:
  image:
    repository: flagsmith.docker.scarf.sh/flagsmith/flagsmith-api
    tag: "" # defaults to .Chart.AppVersion
    imagePullPolicy: IfNotPresent
    imagePullSecrets: []
  replicaCount: 1
  deploymentStrategy: null
  podAnnotations: {}
  resources: {}
  # limits:
  #   cpu: 500m
  #   memory: 500Mi
  # requests:
  #   cpu: 300m
  #   memory: 300Mi
  podLabels: {}
  # https://docs.flagsmith.com/deployment/hosting/locally-api#environment-variables
  extraEnv:
    # Allows authenticating with a local password to Django Admin
    # See https://docs.flagsmith.com/deployment/configuration/django-admin
    ENABLE_ADMIN_ACCESS_USER_PASS: true
  # extraEnvFromSecret:
  #   NAME:
  #    secretName: mysecret
  #    secretKey: mykey
  extraEnvFromSecret: {}
  nodeSelector: {}
  tolerations: []
  affinity: {}
  podSecurityContext: {}
  defaultPodSecurityContext:
    enabled: true
    # runAsNonRoot: true  # TODO: enable this, conditional on tag semver
    # runAsUser: 1000
    # runAsGroup: 1000
  livenessProbe:
    path: /health/liveness
    failureThreshold: 5
    initialDelaySeconds: 5
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 2
  readinessProbe:
    path: /health/readiness
    failureThreshold: 10
    initialDelaySeconds: 1
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 2
  influxdbSetup:
    enabled: false
  extraInitContainers: []
  extraContainers: []
  extraVolumes: []
  volumeMounts: []
  logging:
    format: json # options are generic or json.
  bootstrap:
    # Set to `true` to create initial superuser, organisation, and project.
    # If `adminEmail`, `organisationName` or `projectName` not set, defaults are used.
    # Bootstrapping does nothing if app database is not empty.
    enabled: false
    adminEmail: null
    organisationName: null
    projectName: null
    extraSpec: {} # Will be added to `spec` for `flagsmith-api` deployment.

  # secretKeyFromExistingSecret points to the Secret that contains the Django secret key. If none is provided, a Job
  # will be created to generate one.
  # See https://docs.djangoproject.com/en/4.2/topics/signing/
  secretKeyFromExistingSecret:
    name: ""
    key: ""

frontend:
  # Set this to `false` to switch off the frontend (deployment,
  # service and ingress). Set api.separateApiAndFrontend to false to
  # switch off the deployment but retain the service and ingress
  # pointing at the single Docker image that serves both.
  enabled: true
  image:
    repository: flagsmith.docker.scarf.sh/flagsmith/flagsmith-frontend
    tag: null # defaults to .Chart.AppVersion
    imagePullPolicy: IfNotPresent
    imagePullSecrets: []
  replicacount: 1
  deploymentStrategy: null
  resources: {}
  # limits:
  #   cpu: 500m
  #   memory: 500Mi
  # requests:
  #   cpu: 300m
  #   memory: 300Mi
  apiProxy:
    enabled: true
  extraEnv: {}
  extraEnvFromSecret: {}
  nodeSelector: {}
  tolerations: []
  affinity: {}
  podSecurityContext: {}
  defaultPodSecurityContext:
    enabled: true
    # runAsNonRoot: true  # TODO: enable this, conditional on tag semver
    # runAsUser: 1000
    # runAsGroup: 1000
  livenessProbe:
    failureThreshold: 20
    initialDelaySeconds: 20
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 10
  readinessProbe:
    failureThreshold: 20
    initialDelaySeconds: 20
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 10
  extraInitContainers: []
  extraContainers: []
  extraVolumes: []
  volumeMounts: []
  extraSpec: {} # Will be added to `spec` for `flagsmith-frontend` deployment.

# See https://docs.flagsmith.com/deployment/task-processor
taskProcessor:
  image:
    # all values here default to those in .Values.api.image if not configured
    # this is to simplify the logic for those using flagsmith-api image
    # and to maintain backwards compatibility.
    repository: null
    tag: null
    imagePullPolicy: null
    imagePullSecrets: null

  enabled: false
  replicacount: 1
  sleepIntervalMs: null
  numThreads: null
  gracePeriodMs: null
  queuePopSize: null

  livenessProbe:
    failureThreshold: 5
    initialDelaySeconds: 5
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 30
  readinessProbe:
    failureThreshold: 10
    initialDelaySeconds: 1
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 30

  podAnnotations: {}
  resources: {}
  # limits:
  #   cpu: 500m
  #   memory: 500Mi
  # requests:
  #   cpu: 300m
  #   memory: 300Mi
  podLabels: {}
  nodeSelector: {}
  tolerations: []
  affinity: {}
  podSecurityContext: {}
  defaultPodSecurityContext:
    enabled: true
    # runAsNonRoot: true  # TODO: enable this, conditional on tag semver
    # runAsUser: 1000
    # runAsGroup: 1000
  extraInitContainers: []
  extraContainers: []
  extraEnv: {}
  extraVolumes: []
  volumeMounts: []
  extraSpec: {} # Will be added to `spec` for `flagsmith-task-processor` deployment.

database:
  type: postgres
  # database is a Secret with the logical database name.
  database:
    secret: ""
    key: ""
  # username is a Secret with the database username.
  username:
    secret: ""
    key: ""
  # password is a Secret with the database password.
  password:
    secret: ""
    key: ""
  # host is a Secret with the database hostname.
  host:
    secret: ""
    key: ""

  port: 5432
  portSecret: ""
  portKey: ""

influxdb:
  enabled: false
  url: null
  bucket: null
  organization: null
  token:
    secret: null
    key: null

UsePostgresForAnalytics:
  enabled: false

sse:
  enabled: false
  image:
    repository: flagsmith/sse
    tag: 3.6.0
    imagePullPolicy: IfNotPresent
    imagePullSecrets: []
  # See all supported environment variables here:
  # https://docs.flagsmith.com/deployment/hosting/real-time/deployment#sse-service
  # extraEnv:
  #   REDIS_HOST: redis.example.com
  #   REDIS_PORT: 6379
  #   USE_CLUSTER_MODE: true # - set this if connecting to a Redis cluster, not a single node
  # extraEnvFromSecret:
  #   REDIS_PASSWORD:
  #    secretName: my_redis_secrets
  #    secretKey: my_redis_password

  # authenticationTokenFromExistingSecret is a shared secret between the API and SSE service. If none is provided, a Job
  # will be created to generate one.
  authenticationTokenFromExistingSecret:
    enabled: false
    name: ""
    key: ""
  replicaCount: 1
  deploymentStrategy: null
  podAnnotations: {}
  resources: {}
  # limits:
  #   cpu: 500m
  #   memory: 500Mi
  # requests:
  #   cpu: 300m
  #   memory: 300Mi
  podLabels: {}
  nodeSelector: {}
  tolerations: []
  affinity: {}
  podSecurityContext: {}
  defaultPodSecurityContext:
    enabled: true
    # runAsNonRoot: true  # TODO: enable this, conditional on tag semver
    # runAsUser: 1000
    # runAsGroup: 1000
  livenessProbe:
    path: /health/liveness
    failureThreshold: 5
    initialDelaySeconds: 5
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 2
  readinessProbe:
    path: /health/readiness
    failureThreshold: 10
    initialDelaySeconds: 1
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 2
  shareProcessNamespace: false
  serviceAccountName: null
  extraInitContainers: []
  extraContainers: []
  extraVolumes: []
  volumeMounts: []

service:
  api:
    type: ClusterIP
    port: 8000
    annotations: {}
  frontend:
    type: ClusterIP
    port: 8080
    annotations: {}
  sse:
    type: ClusterIP
    port: 8000
    annotations: {}
  taskProcessor:
    type: ClusterIP
    port: 8000
    annotations: {}

hpa:
  api:
    enabled: false
    minReplicas: 2
    maxReplicas: 10
    targetCPUUtilization: 50

ingress:
  frontend:
    enabled: false
    annotations: {}
    ingressClassName: null
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
    hosts:
      - chart-example.local
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local
  api:
    enabled: false
    annotations: {}
    ingressClassName: null
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
    hosts:
      - host: chart-example.local
        paths: []
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local
  sse:
    enabled: false
    annotations: {}
    ingressClassName: null
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
    hosts:
      - host: chart-example.local
        paths: []
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

jobs:
  migrateDb:
    enabled: true
    ttlSecondsAfterFinished: 3600
    restartPolicy: OnFailure
    defaultPodSecurityContext:
      enabled: true
      # runAsNonRoot: true
    extraContainers: []
    extraVolumes: []
    command: []
    args: []
  migrateAnalyticsData:
    enabled: false
    args: []
    extraContainers: []
    extraVolumes: []

# These tests just make non-destructive requests to the services in
# the cluster. Enabling this and running helm test is safe.
tests:
  enabled: false

# -- Array of extra K8s manifests to deploy
## Note: Supports use of custom Helm templates
## Example: Deploying a CloudnativePG Postgres cluster for use with Flagmsith:
extraObjects: []
# - |
#   apiVersion: postgresql.cnpg.io/v1
#   kind: Cluster
#   metadata:
#     name: flagsmith
#     namespace: {{ .Release.Namespace }}
#   spec:
#     instances: 3
#     storage:
#       size: 10Gi
